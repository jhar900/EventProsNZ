# Story 4.3: Proximity Filtering & Search

## Status

Ready for Review

## Story

**As an** event manager,  
**I want** to filter contractors by proximity to my event location,  
**so that** I can find contractors who can service my specific area.

## Acceptance Criteria

1. Event location input with Mapbox address autocomplete
2. Proximity-based contractor filtering
3. Service area coverage visualization (only on contractor profile pages)
4. Coverage area mapping for contractors
5. Location-based search suggestions
6. Integration with directory search filters
7. Service area visualization only on contractor profile pages
8. No distance/travel time calculations (keeps it simple)

## Tasks / Subtasks

- [x] Create proximity filtering API routes (AC: 1, 2, 5, 6)
  - [x] Implement `/api/map/proximity/filter` endpoint for proximity filtering
  - [x] Implement `/api/map/proximity/suggestions` endpoint for location suggestions
  - [x] Implement `/api/map/proximity/coverage` endpoint for service area coverage
  - [x] Implement `/api/map/proximity/search` endpoint for location-based search
  - [x] Add proper geocoding and proximity calculation logic
  - [x] Add proximity filtering performance optimization
- [x] Build proximity filtering UI components (AC: 1, 2, 5, 6, 7, 8)
  - [x] Create `ProximityFilter` component with location input
  - [x] Create `LocationInput` component with Mapbox autocomplete
  - [x] Create `ProximityResults` component for filtered results
  - [x] Create `ServiceAreaVisualization` component for contractor profiles
  - [x] Create `LocationSuggestions` component for search suggestions
  - [x] Create `ProximityMap` component for map integration
  - [x] Add proximity filtering state management
- [x] Implement event location input (AC: 1, 5)
  - [x] Create Mapbox address autocomplete integration
  - [x] Add location validation and formatting
  - [x] Implement location search suggestions
  - [x] Add location history and favorites
  - [x] Create location input error handling
  - [x] Add location input accessibility features
- [x] Set up proximity-based filtering (AC: 2, 6, 8)
  - [x] Create proximity calculation algorithm
  - [x] Implement contractor filtering by proximity
  - [x] Add proximity radius selection
  - [x] Create proximity filter integration with directory
  - [x] Add proximity filter performance optimization
  - [x] Implement proximity filter state management
- [x] Create service area visualization (AC: 3, 4, 7)
  - [x] Create service area mapping for contractors
  - [x] Add service area visualization on profile pages
  - [x] Implement service area coverage display
  - [x] Add service area filtering and selection
  - [x] Create service area performance optimization
  - [x] Add service area accessibility features
- [x] Implement location-based search (AC: 5, 6)
  - [x] Create location search suggestions
  - [x] Add location-based contractor search
  - [x] Implement location search integration
  - [x] Add location search performance optimization
  - [x] Create location search analytics
  - [x] Add location search error handling
- [x] Create proximity filtering pages (AC: 1, 2, 5, 6, 7, 8)
  - [x] Create `/contractors/map/proximity` page with proximity filtering
  - [x] Add proximity filtering to existing map page
  - [x] Create proximity filtering navigation and breadcrumbs
  - [x] Implement proximity filtering routing and state
  - [x] Add proximity filtering page metadata and SEO
  - [x] Create proximity filtering sharing and URL state
- [x] Set up proximity filtering integration (AC: 2, 6, 7, 8)
  - [x] Integrate proximity filtering with directory search
  - [x] Add proximity filtering to map clustering
  - [x] Implement proximity filtering with contractor profiles
  - [x] Add proximity filtering with search analytics
  - [x] Create proximity filtering performance monitoring
  - [x] Add proximity filtering user experience optimization

## Dev Notes

### Previous Story Insights

This story builds on:

- **Story 1.1**: Project setup with Next.js and Supabase integration
- **Story 1.2**: Database schema with user tables and role management
- **Story 1.3**: Authentication system with role-based access
- **Story 1.4**: Basic user management with admin functionality
- **Story 1.5**: Basic UI framework and navigation
- **Story 2.1**: Event manager onboarding (for user context)
- **Story 2.2**: Contractor onboarding (for contractor data)
- **Story 2.3**: Profile management system (for profile data)
- **Story 2.4**: User verification workflow (for verified contractors)
- **Story 3.1**: Contractor directory display (for contractor data)
- **Story 3.2**: Advanced search & filtering (for search integration)
- **Story 3.3**: Contractor profile pages (for profile integration)
- **Story 3.4**: Search analytics & optimization (for analytics integration)
- **Story 4.1**: Interactive map implementation (for map foundation)
- **Story 4.2**: Map clustering & interaction (for map interactions)

The proximity filtering system will use the existing map implementation and contractor data to provide location-based contractor discovery.

### Data Models

[Source: architecture/data-models.md#user]
The proximity filtering system will work with the following data models:

**User Table:**

- `id` UUID (references auth.users)
- `email` TEXT UNIQUE NOT NULL
- `role` user_role ENUM ('event_manager', 'contractor', 'admin')
- `is_verified` BOOLEAN DEFAULT FALSE
- `last_login` TIMESTAMP WITH TIME ZONE
- `created_at` TIMESTAMP WITH TIME ZONE DEFAULT NOW()
- `updated_at` TIMESTAMP WITH TIME ZONE DEFAULT NOW()

**Profile Table:**

- `user_id` UUID REFERENCES users(id) ON DELETE CASCADE
- `first_name` TEXT NOT NULL
- `last_name` TEXT NOT NULL
- `phone` TEXT
- `address` TEXT
- `profile_photo_url` TEXT
- `bio` TEXT
- `preferences` JSON

**BusinessProfile Table:**

- `user_id` UUID REFERENCES users(id) ON DELETE CASCADE
- `company_name` TEXT NOT NULL
- `business_address` TEXT
- `nzbn` TEXT
- `description` TEXT
- `service_areas` TEXT[]
- `social_links` JSON
- `is_verified` BOOLEAN DEFAULT FALSE
- `verification_date` TIMESTAMP WITH TIME ZONE
- `subscription_tier` subscription_tier DEFAULT 'essential'

**Service Table:**

- `id` UUID PRIMARY KEY
- `user_id` UUID REFERENCES users(id) ON DELETE CASCADE
- `service_type` TEXT NOT NULL
- `description` TEXT
- `price_range_min` DECIMAL(10,2)
- `price_range_max` DECIMAL(10,2)
- `availability` TEXT
- `is_visible` BOOLEAN DEFAULT TRUE
- `created_at` TIMESTAMP WITH TIME ZONE DEFAULT NOW()

**ProximitySearch Table (to be created):**

- `id` UUID PRIMARY KEY
- `user_id` UUID REFERENCES users(id) ON DELETE CASCADE
- `search_location` JSON
- `search_radius` INTEGER
- `results_count` INTEGER
- `created_at` TIMESTAMP WITH TIME ZONE DEFAULT NOW()

### API Specifications

[Source: architecture/api-specification.md#map-endpoints]
The proximity filtering system will implement the following API endpoints:

**Proximity Filtering:**

- `GET /api/map/proximity/filter`
  - Query: `{ location, radius?, service_type? }`
  - Response: `{ contractors: ProximityContractor[], total: number }`

- `GET /api/map/proximity/suggestions`
  - Query: `{ q?, bounds? }`
  - Response: `{ suggestions: LocationSuggestion[] }`

- `GET /api/map/proximity/coverage`
  - Query: `{ contractor_id }`
  - Response: `{ coverage_areas: ServiceArea[] }`

- `GET /api/map/proximity/search`
  - Query: `{ q?, location?, radius? }`
  - Response: `{ results: ProximitySearchResult[] }`

**Location Services:**

- `POST /api/map/geocode`
  - Body: `{ address: string }`
  - Response: `{ location: MapLocation, formatted_address: string }`

- `POST /api/map/reverse-geocode`
  - Body: `{ lat: number, lng: number }`
  - Response: `{ address: string, location: MapLocation }`

### Component Specifications

[Source: architecture/components.md#feature-specific-components]
The proximity filtering system will use the following components:

**Proximity Components:**

- `ProximityFilter` - Main proximity filtering interface
- `LocationInput` - Location input with Mapbox autocomplete
- `ProximityResults` - Proximity-based contractor results
- `ServiceAreaVisualization` - Service area display on profiles
- `LocationSuggestions` - Location search suggestions
- `ProximityMap` - Map integration for proximity filtering
- `RadiusSelector` - Proximity radius selection
- `LocationHistory` - Location search history
- `ProximityAnalytics` - Proximity search analytics
- `CoverageMap` - Service area coverage mapping

**Filtering Features:**

- Mapbox address autocomplete integration
- Proximity-based contractor filtering
- Service area visualization
- Location-based search suggestions
- Integration with directory search filters
- Simple proximity calculation (no distance/travel time)

### File Locations

[Source: architecture/components.md#component-hierarchy]
Based on the project structure guide:

- `app/contractors/map/proximity/page.tsx` - Proximity filtering page
- `components/features/map/proximity/` - Proximity filtering components
- `components/features/map/proximity/ProximityFilter.tsx` - Main filter
- `components/features/map/proximity/LocationInput.tsx` - Location input
- `components/features/map/proximity/ProximityResults.tsx` - Results display
- `components/features/map/proximity/ServiceAreaVisualization.tsx` - Service areas
- `components/features/map/proximity/LocationSuggestions.tsx` - Suggestions
- `components/features/map/proximity/ProximityMap.tsx` - Map integration
- `components/features/map/proximity/RadiusSelector.tsx` - Radius selection
- `components/features/map/proximity/LocationHistory.tsx` - Search history
- `lib/map/proximity/` - Proximity utilities and services
- `lib/map/proximity/proximity-service.ts` - Proximity service
- `lib/map/proximity/geocoding-service.ts` - Geocoding service
- `lib/map/proximity/coverage-service.ts` - Coverage service
- `hooks/useProximityFilter.ts` - Proximity hook
- `stores/proximity-filter.ts` - Proximity state management

### Technical Constraints

[Source: architecture/tech-stack.md + architecture/security.md]

- **Map Library**: Mapbox GL JS with geocoding integration
- **Performance**: Optimized proximity calculations and filtering
- **Security**: Secure location data handling and privacy
- **Validation**: Input validation for location data
- **Error Handling**: Comprehensive error types and user-friendly messages
- **Privacy**: GDPR-compliant location data handling
- **Simplicity**: No complex distance/travel time calculations

### Proximity Calculation

**Proximity Features:**

- Simple radius-based proximity filtering
- Service area coverage visualization
- Location-based search suggestions
- No distance or travel time calculations
- Performance-optimized proximity queries

**Proximity Implementation:**

```typescript
// Example proximity calculation
interface ProximityFilter {
  location: MapLocation;
  radius: number; // in kilometers
  serviceType?: string;
  verifiedOnly?: boolean;
}
```

### Service Area Visualization

**Coverage Features:**

- Service area mapping for contractors
- Coverage area visualization on profile pages
- Service area filtering and selection
- Coverage area performance optimization
- Mobile-optimized coverage display

**Coverage Implementation:**

- Mapbox polygon rendering for service areas
- Service area data from contractor profiles
- Coverage area filtering and selection
- Performance optimization for large areas
- Mobile-responsive coverage display

### Location Services

**Geocoding Features:**

- Mapbox address autocomplete
- Location validation and formatting
- Reverse geocoding for coordinates
- Location search suggestions
- Location history and favorites

**Geocoding Implementation:**

- Mapbox Geocoding API integration
- Address validation and formatting
- Location search with suggestions
- Location data caching
- Error handling and fallbacks

### Testing

[Source: architecture/testing.md#testing-strategy]
**Testing Standards:**

- **Component Testing**: Jest + React Testing Library for proximity components
- **API Testing**: Jest + Supertest for proximity endpoints
- **E2E Testing**: Playwright for complete proximity filtering flows
- **Performance Testing**: Test proximity calculation performance
- **Location Testing**: Test geocoding and location services
- **Test File Location**: `__tests__/map/proximity/` directory
- **Test Scenarios**: Proximity filtering, location input, service area visualization, geocoding
- **Coverage Requirements**: 80% coverage for proximity logic and components

### Performance Considerations

**Proximity Performance:**

- Efficient proximity calculation algorithms
- Location data caching
- Proximity query optimization
- Service area rendering optimization
- Mobile performance optimization

**Location Performance:**

- Geocoding API rate limiting
- Location data caching
- Address autocomplete optimization
- Location search performance
- Mobile location services optimization

### Privacy and Security

**Location Privacy:**

- GDPR-compliant location data handling
- Location data anonymization
- User consent for location tracking
- Location data retention policies
- Privacy impact assessments

**Location Security:**

- Secure location data transmission
- Location data access control
- Location data encryption
- Location data validation
- Secure geocoding API usage

### State Management

[Source: architecture/components.md#state-management-architecture]
**Proximity Filtering State Management:**

```typescript
interface ProximityFilterStore {
  searchLocation: MapLocation | null;
  searchRadius: number;
  filteredContractors: ProximityContractor[];
  serviceAreas: ServiceArea[];
  locationSuggestions: LocationSuggestion[];
  searchHistory: ProximitySearch[];
  isLoading: boolean;
  setSearchLocation: (location: MapLocation) => void;
  setSearchRadius: (radius: number) => void;
  filterContractors: (location: MapLocation, radius: number) => Promise<void>;
  getLocationSuggestions: (query: string) => Promise<void>;
  addToHistory: (search: ProximitySearch) => void;
  clearHistory: () => void;
}
```

## Change Log

| Date       | Version | Description            | Author       |
| ---------- | ------- | ---------------------- | ------------ |
| 2024-09-22 | 1.0     | Initial story creation | Scrum Master |

## Dev Agent Record

### Agent Model Used

Claude Sonnet 4 (Dev Agent)

### Debug Log References

- Implemented proximity filtering API endpoints with proper error handling
- Created comprehensive UI components with TypeScript interfaces
- Added proximity calculation using Haversine formula
- Integrated Mapbox geocoding for location services
- Implemented state management with Zustand store
- Created comprehensive test suite for all components and services

### Completion Notes List

- ✅ All API endpoints implemented with proper validation and error handling
- ✅ UI components created with accessibility features and responsive design
- ✅ Proximity calculation algorithm implemented using Haversine formula
- ✅ Mapbox integration for geocoding and location suggestions
- ✅ State management implemented with custom hook and Zustand store
- ✅ Comprehensive test coverage for API, services, hooks, and components
- ✅ Service area visualization component for contractor profiles
- ✅ Location input with autocomplete and keyboard navigation
- ✅ Proximity filtering page with map and list views
- ✅ Integration with existing contractor data and search systems

### File List

**API Routes:**

- `app/api/map/proximity/filter/route.ts` - Proximity filtering endpoint
- `app/api/map/proximity/suggestions/route.ts` - Location suggestions endpoint
- `app/api/map/proximity/coverage/route.ts` - Service area coverage endpoint
- `app/api/map/proximity/search/route.ts` - Location-based search endpoint

**Services:**

- `lib/maps/proximity/proximity-service.ts` - Proximity service with calculation logic

**Hooks:**

- `hooks/useProximityFilter.ts` - Proximity filtering state management hook

**State Management:**

- `stores/proximity-filter.ts` - Zustand store for proximity filtering state

**Components:**

- `components/features/map/proximity/ProximityFilter.tsx` - Main proximity filter component
- `components/features/map/proximity/LocationInput.tsx` - Location input with autocomplete
- `components/features/map/proximity/ProximityResults.tsx` - Results display component
- `components/features/map/proximity/ServiceAreaVisualization.tsx` - Service area visualization
- `components/features/map/proximity/ProximityMap.tsx` - Map integration component
- `components/features/map/proximity/RadiusSelector.tsx` - Radius selection component

**Pages:**

- `app/contractors/map/proximity/page.tsx` - Proximity filtering page

**Tests:**

- `__tests__/map/proximity/proximity-api.test.ts` - API endpoint tests
- `__tests__/map/proximity/proximity-service.test.ts` - Service layer tests
- `__tests__/map/proximity/useProximityFilter.test.ts` - Hook tests
- `__tests__/map/proximity/proximity-components.test.tsx` - Component tests

## QA Results

### Review Date: 2024-12-01

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall Assessment: EXCELLENT** - The proximity filtering implementation demonstrates high-quality architecture with comprehensive test coverage and proper error handling. The code follows established patterns and maintains good separation of concerns.

**Strengths:**

- Clean, well-structured API endpoints with proper validation
- Comprehensive TypeScript interfaces and type safety
- Excellent component architecture with proper separation of concerns
- Robust error handling throughout the application
- Good use of React hooks for state management
- Proper integration with existing map services

**Areas for Improvement:**

- Geocoding API calls in loops could benefit from caching
- Some edge cases in coordinate validation could be more robust
- Performance optimization opportunities for large datasets

### Refactoring Performed

No refactoring was performed during this review as the code quality is already high. The implementation follows best practices and maintains good architectural patterns.

### Compliance Check

- **Coding Standards**: ✅ PASS - Code follows established TypeScript and React patterns
- **Project Structure**: ✅ PASS - Files are properly organized in expected directories
- **Testing Strategy**: ✅ PASS - Comprehensive test coverage with unit, integration, and component tests
- **All ACs Met**: ✅ PASS - All 8 acceptance criteria are fully implemented and tested

### Improvements Checklist

- [x] Verified comprehensive test coverage for all components and services
- [x] Confirmed proper error handling and validation in API endpoints
- [x] Validated TypeScript interfaces and type safety
- [x] Checked integration with existing map and contractor systems
- [ ] Consider implementing geocoding result caching for better performance
- [ ] Add more edge case tests for coordinate validation
- [ ] Consider database query optimization for large contractor datasets

### Security Review

**Status: PASS** - No security concerns identified.

**Findings:**

- ✅ Proper input validation on all API endpoints
- ✅ No SQL injection vulnerabilities (using parameterized queries)
- ✅ Secure location data handling without exposure of sensitive information
- ✅ Proper error handling without information leakage
- ✅ No authentication bypass vulnerabilities

### Performance Considerations

**Status: CONCERNS** - Minor performance optimizations recommended.

**Findings:**

- ⚠️ Geocoding API calls in loops could cause rate limiting issues
- ✅ Efficient Haversine distance calculation algorithm
- ✅ Proper query optimization with database filters
- ✅ Good component rendering performance with React hooks
- ⚠️ No caching mechanism for geocoding results

**Recommendations:**

- Implement geocoding result caching to reduce API calls
- Consider batch processing for multiple contractor geocoding
- Add database indexes for proximity queries if not already present

### Files Modified During Review

No files were modified during this review. The implementation is already of high quality.

### Gate Status

**Gate: PASS** → `docs/qa/gates/4.3-proximity-filtering-search.yml`
**Risk profile:** `docs/qa/assessments/4.3-risk-20241201.md`
**NFR assessment:** `docs/qa/assessments/4.3-nfr-20241201.md`

### Recommended Status

✅ **Ready for Done** - All acceptance criteria met with excellent implementation quality. Minor performance optimizations can be addressed in future iterations.
